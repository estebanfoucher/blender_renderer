"""
Blender script generator for rendering point cloud sequences.
"""

import logging
from pathlib import Path
from typing import Dict, Any, List, Optional
import json


class BlenderScriptGenerator:
    """
    Generates Blender Python scripts for rendering point cloud sequences.
    
    Creates scripts that can be executed by Blender to render point cloud
    animations with custom camera trajectories.
    """
    
    def __init__(self):
        """Initialize the script generator."""
        self.logger = logging.getLogger(__name__)
    
    def generate_script(self,
                       point_clouds: List[Dict[str, Any]],
                       camera_trajectory,
                       render_settings: Dict[str, Any],
                       output_dir: Path,
                       script_path: Path) -> None:
        """
        Generate a complete Blender Python script.
        
        Args:
            point_clouds: List of point cloud data
            camera_trajectory: CameraTrajectory instance
            render_settings: Render settings dictionary
            output_dir: Output directory for rendered frames
            script_path: Path where to save the generated script
        """
        script_content = self._generate_script_content(
            point_clouds, camera_trajectory, render_settings, output_dir
        )
        
        with open(script_path, 'w') as f:
            f.write(script_content)
        
        self.logger.info(f"Generated Blender script: {script_path}")
    
    def _generate_script_content(self,
                                point_clouds: List[Dict[str, Any]],
                                camera_trajectory,
                                render_settings: Dict[str, Any],
                                output_dir: Path) -> str:
        """Generate the complete script content."""
        
        # Script header
        script = '''#!/usr/bin/env python3
"""
Auto-generated Blender script for point cloud rendering.
Generated by blender-pointcloud-renderer
"""

import bpy
import bmesh
import os
import sys
import json
import numpy as np
from mathutils import Vector, Euler
from pathlib import Path

# Clear existing mesh objects
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete(use_global=False)

# Clear existing materials
for material in bpy.data.materials:
    bpy.data.materials.remove(material)

# Clear existing meshes
for mesh in bpy.data.meshes:
    bpy.data.meshes.remove(mesh)

'''
        
        # Add point cloud file list (not data)
        script += self._generate_point_cloud_files_section(point_clouds)
        
        # Add camera trajectory data
        script += self._generate_camera_trajectory_section(camera_trajectory)
        
        # Add render settings
        script += self._generate_render_settings_section(render_settings)
        
        # Add main rendering logic
        script += self._generate_rendering_logic_section(output_dir)
        
        return script
    
    def _generate_point_cloud_files_section(self, point_clouds: List[Dict[str, Any]]) -> str:
        """Generate the point cloud files section (file paths only)."""
        script = '''
# Point cloud files to process
POINT_CLOUD_FILES = [
'''
        
        for pc_data in point_clouds:
            script += f"    r\"{pc_data['file_path']}\",\n"
        
        script += "]\n\n"
        return script
    
    def _generate_camera_trajectory_section(self, camera_trajectory) -> str:
        """Generate the camera trajectory section."""
        trajectory_info = camera_trajectory.get_info()
        
        script = f'''
# Camera trajectory
CAMERA_TRAJECTORY = {json.dumps(trajectory_info, indent=4).replace('null', 'None')}

def get_camera_transform(frame, total_frames):
    """Get camera transform for a specific frame."""
    import math
    
    trajectory = CAMERA_TRAJECTORY
    
    if trajectory['type'] == 'circular':
        params = trajectory['parameters']
        t = (frame - 1) / (total_frames - 1) if total_frames > 1 else 0
        angle = params['start_angle'] + t * (params['end_angle'] - params['start_angle'])
        
        center = params['center']
        radius = params['radius']
        height = params['height']
        
        x = center[0] + radius * math.cos(angle)
        y = center[1] + radius * math.sin(angle)
        z = center[2] + height
        
        location = (x, y, z)
        look_at = params['look_at']
        
        # Calculate rotation to look at target
        direction = np.array(look_at) - np.array(location)
        direction = direction / np.linalg.norm(direction)
        
        yaw = math.atan2(direction[0], direction[2])
        pitch = math.asin(-direction[1])
        
        rotation = (pitch, 0.0, yaw)
        
    elif trajectory['type'] == 'linear':
        params = trajectory['parameters']
        t = (frame - 1) / (total_frames - 1) if total_frames > 1 else 0
        
        start_pos = params['start_pos']
        end_pos = params['end_pos']
        
        location = (
            start_pos[0] + t * (end_pos[0] - start_pos[0]),
            start_pos[1] + t * (end_pos[1] - start_pos[1]),
            start_pos[2] + t * (end_pos[2] - start_pos[2])
        )
        
        # Use fixed rotation if provided, otherwise calculate look-at rotation
        if params.get('fixed_rotation') is not None:
            rotation = params['fixed_rotation']
        elif params.get('look_at') is not None:
            look_at = params['look_at']
            direction = np.array(look_at) - np.array(location)
            direction = direction / np.linalg.norm(direction)
            
            yaw = math.atan2(direction[0], direction[2])
            pitch = math.asin(-direction[1])
            
            rotation = (pitch, 0.0, yaw)
        else:
            rotation = (0.0, 0.0, 0.0)
        
    elif trajectory['type'] == 'custom':
        keyframes = trajectory['keyframes']
        keyframes = sorted(keyframes, key=lambda k: k['frame'])
        
        if frame <= keyframes[0]['frame']:
            location = keyframes[0]['location']
            rotation = keyframes[0]['rotation']
        elif frame >= keyframes[-1]['frame']:
            location = keyframes[-1]['location']
            rotation = keyframes[-1]['rotation']
        else:
            for i in range(len(keyframes) - 1):
                kf1 = keyframes[i]
                kf2 = keyframes[i + 1]
                
                if kf1['frame'] <= frame <= kf2['frame']:
                    t = (frame - kf1['frame']) / (kf2['frame'] - kf1['frame'])
                    
                    loc1 = np.array(kf1['location'])
                    loc2 = np.array(kf2['location'])
                    location = tuple(loc1 + t * (loc2 - loc1))
                    
                    rot1 = np.array(kf1['rotation'])
                    rot2 = np.array(kf2['rotation'])
                    rotation = tuple(rot1 + t * (rot2 - rot1))
                    break
    
    return location, rotation

'''
        return script
    
    def _generate_render_settings_section(self, render_settings: Dict[str, Any]) -> str:
        """Generate the render settings section."""
        script = f'''
# Render settings
RENDER_SETTINGS = {json.dumps(render_settings, indent=4)}

def setup_render_settings():
    """Setup Blender render settings."""
    scene = bpy.context.scene
    render = scene.render
    
    # Resolution
    render.resolution_x = RENDER_SETTINGS['resolution_x']
    render.resolution_y = RENDER_SETTINGS['resolution_y']
    render.resolution_percentage = 100
    
    # Frame range
    scene.frame_start = RENDER_SETTINGS['frame_start']
    scene.frame_end = RENDER_SETTINGS['frame_end']
    scene.frame_current = RENDER_SETTINGS['frame_start']
    
    # FPS
    scene.render.fps = RENDER_SETTINGS['fps']
    
    # Output settings
    render.image_settings.file_format = RENDER_SETTINGS['file_format']
    render.image_settings.color_mode = RENDER_SETTINGS['color_mode']
    render.image_settings.color_depth = RENDER_SETTINGS['color_depth']
    if 'compression' in RENDER_SETTINGS:
        render.image_settings.compression = RENDER_SETTINGS['compression']
    
    # Background color
    world = bpy.context.scene.world
    if world is None:
        world = bpy.data.worlds.new("World")
        bpy.context.scene.world = world
    
    bg_color = RENDER_SETTINGS['background_color']
    world.use_nodes = True
    bg_node = world.node_tree.nodes.get("Background")
    if bg_node:
        bg_node.inputs[0].default_value = bg_color

'''
        return script
    
    def _generate_rendering_logic_section(self, output_dir: Path) -> str:
        """Generate the main rendering logic section."""
        script = f'''
def load_ply_file(file_path):
    """
    Load PLY file and return data in the EXACT format used in sphere_optimized_script.py:
    - points: np.array with dtype=float64 (default numpy dtype)
    - colors: np.array with dtype=float64 (default numpy dtype) 
    - Colors normalized from [0,255] to [0,1] range
    """
    print(f"Loading PLY file: {{file_path}}")
    
    points = []
    colors = []
    
    with open(file_path, 'r') as f:
        lines = f.readlines()
    
    # Find the header end
    header_end = 0
    vertex_count = 0
    has_colors = False
    
    for i, line in enumerate(lines):
        line = line.strip()
        if line.startswith('element vertex'):
            vertex_count = int(line.split()[-1])
            print(f"Found {{vertex_count}} vertices")
        elif line.startswith('property uchar red'):
            has_colors = True
            print("Found color properties (uchar)")
        elif line == 'end_header':
            header_end = i + 1
            break
    
    print(f"Header ends at line {{header_end}}, has_colors: {{has_colors}}")
    
    # Parse vertex data
    for i in range(header_end, header_end + vertex_count):
        if i >= len(lines):
            break
            
        parts = lines[i].strip().split()
        if len(parts) >= 3:
            # Extract coordinates (float values)
            x, y, z = float(parts[0]), float(parts[1]), float(parts[2])
            points.append([x, y, z])
            
            # Extract colors if available (uchar values 0-255)
            if has_colors and len(parts) >= 6:
                r, g, b = int(parts[3]), int(parts[4]), int(parts[5])
                # Normalize colors from [0, 255] to [0, 1] - EXACTLY like working script
                colors.append([r/255.0, g/255.0, b/255.0])
            elif has_colors:
                # Default color if missing
                colors.append([1.0, 1.0, 1.0])
    
    # Convert to numpy arrays with EXACT same dtype as working script (float64 default)
    points = np.array(points)  # Default dtype is float64
    colors = np.array(colors) if colors else None  # Default dtype is float64
    
    print(f"Loaded {{len(points)}} points, has_colors: {{colors is not None}}")
    print(f"Points dtype: {{points.dtype}}, Colors dtype: {{colors.dtype if colors is not None else 'None'}}")
    
    if len(points) > 0:
        min_coords = np.min(points, axis=0)
        max_coords = np.max(points, axis=0)
        print(f"Point bounds: X[{{min_coords[0]:.6f}}, {{max_coords[0]:.6f}}], "
              f"Y[{{min_coords[1]:.6f}}, {{max_coords[1]:.6f}}], "
              f"Z[{{min_coords[2]:.6f}}, {{max_coords[2]:.6f}}]")
        
        if colors is not None:
            min_colors = np.min(colors, axis=0)
            max_colors = np.max(colors, axis=0)
            print(f"Color bounds: R[{{min_colors[0]:.6f}}, {{max_colors[0]:.6f}}], "
                  f"G[{{min_colors[1]:.6f}}, {{max_colors[1]:.6f}}], "
                  f"B[{{min_colors[2]:.6f}}, {{max_colors[2]:.6f}}]")
    
    return points, colors

def create_point_cloud_material():
    """Create material for point cloud sphere rendering."""
    material = bpy.data.materials.new(name="PointCloudMaterial")
    material.use_nodes = True
    
    # Clear default nodes
    material.node_tree.nodes.clear()
    
    # Add principled BSDF for realistic sphere rendering
    principled_node = material.node_tree.nodes.new(type='ShaderNodeBsdfPrincipled')
    principled_node.inputs['Specular IOR Level'].default_value = 0.5
    principled_node.inputs['Roughness'].default_value = 0.3  # Slightly rough for realistic spheres
    
    # Add output node
    output_node = material.node_tree.nodes.new(type='ShaderNodeOutputMaterial')
    
    # Connect nodes
    material.node_tree.links.new(principled_node.outputs['BSDF'], output_node.inputs['Surface'])
    
    return material

def create_sphere_objects(points, colors=None, sphere_radius=0.01):
    """Create individual sphere objects for each point (EXACT same as working direct approach)."""
    print(f"Creating {{len(points)}} sphere objects with radius {{sphere_radius}}")
    
    # Create base sphere mesh
    bpy.ops.mesh.primitive_uv_sphere_add(radius=sphere_radius, location=(0, 0, 0))
    base_sphere = bpy.context.object
    base_sphere.name = "BaseSphere"
    
    # Create material for spheres
    material = create_point_cloud_material()
    base_sphere.data.materials.append(material)
    
    # Create a collection for all spheres
    sphere_collection = bpy.data.collections.new("PointCloudSpheres")
    bpy.context.scene.collection.children.link(sphere_collection)
    
    # Create spheres for each point
    sphere_objects = []
    for i, point in enumerate(points):
        # Duplicate the base sphere
        sphere_obj = base_sphere.copy()
        sphere_obj.data = base_sphere.data.copy()
        sphere_obj.name = f"Sphere_{{i:04d}}"
        
        # Set position
        sphere_obj.location = point
        
        # Set color if available
        if colors is not None and i < len(colors):
            # Create a new material for this sphere with the specific color
            sphere_material = material.copy()
            sphere_material.name = f"SphereMaterial_{{i:04d}}"
            
            # Normalize color to [0, 1] if needed
            color = colors[i]
            if color.max() > 1.0:
                color = color / 255.0
            
            # Set the base color
            principled_node = sphere_material.node_tree.nodes.get('Principled BSDF')
            if principled_node:
                principled_node.inputs['Base Color'].default_value = (*color, 1.0)
            
            # Assign material
            sphere_obj.data.materials.clear()
            sphere_obj.data.materials.append(sphere_material)
        
        # Link to collection
        sphere_collection.objects.link(sphere_obj)
        sphere_objects.append(sphere_obj)
    
    # Remove the base sphere from the scene
    bpy.data.objects.remove(base_sphere, do_unlink=True)
    
    print(f"✅ Created {{len(sphere_objects)}} sphere objects with radius {{sphere_radius}}")
    return sphere_objects

def setup_camera():
    """Setup camera for rendering."""
    # Create camera if it doesn't exist
    if 'Camera' not in bpy.data.objects:
        bpy.ops.object.camera_add()
        camera = bpy.context.object
        camera.name = 'Camera'
    else:
        camera = bpy.data.objects['Camera']
    
    # Set camera type to perspective
    camera.data.type = 'PERSP'
    camera.data.lens = 50.0  # 50mm lens
    
    # Make sure the camera is the active camera for rendering
    bpy.context.scene.camera = camera
    
    print(f"Camera created: {{camera.name}}")
    print(f"Active camera: {{bpy.context.scene.camera.name if bpy.context.scene.camera else 'None'}}")
    
    return camera

def main():
    """Main rendering function."""
    print("Starting point cloud rendering...")
    
    # Setup render settings
    setup_render_settings()
    
    # Setup camera
    camera = setup_camera()
    
    # Create output directory
    output_path = Path(r"{output_dir}")
    output_path.mkdir(parents=True, exist_ok=True)
    
    # Set output path
    bpy.context.scene.render.filepath = str(output_path / "frame_")
    
    # Get total frames
    total_frames = len(POINT_CLOUD_FILES)
    bpy.context.scene.frame_end = total_frames
    
    print(f"Rendering {{total_frames}} frames...")
    
    # Render each frame
    for i, ply_file_path in enumerate(POINT_CLOUD_FILES):
        frame_number = i + 1
        
        print(f"Rendering frame {{frame_number}} ({{i+1}}/{{total_frames}}): {{Path(ply_file_path).name}}")
        
        # Set current frame
        bpy.context.scene.frame_current = frame_number
        
        # Load point cloud data from PLY file
        points, colors = load_ply_file(ply_file_path)
        
        if points is None:
            print(f"Failed to load point cloud for frame {{frame_number}}")
            continue
        
        print(f"Loaded {{len(points)}} points for frame {{frame_number}}")
        if colors is not None:
            print(f"Loaded {{len(colors)}} colors for frame {{frame_number}}")
        else:
            print(f"No colors loaded for frame {{frame_number}}")
        
        # Print point cloud bounds for debugging
        if len(points) > 0:
            print(f"Point cloud bounds - X: {{points[:, 0].min():.2f}} to {{points[:, 0].max():.2f}}")
            print(f"Point cloud bounds - Y: {{points[:, 1].min():.2f}} to {{points[:, 1].max():.2f}}")
            print(f"Point cloud bounds - Z: {{points[:, 2].min():.2f}} to {{points[:, 2].max():.2f}}")
            print(f"Point cloud center: ({{points[:, 0].mean():.2f}}, {{points[:, 1].mean():.2f}}, {{points[:, 2].mean():.2f}})")
        
        # Clear existing point cloud objects
        for obj in bpy.context.scene.objects:
            if obj.name.startswith("PointCloud") or obj.name.startswith("Sphere_"):
                bpy.data.objects.remove(obj, do_unlink=True)
        
        # Clear existing collections
        for collection in bpy.data.collections:
            if collection.name.startswith("PointCloudSpheres"):
                bpy.data.collections.remove(collection)
        
        # Create new point cloud object
        sphere_objects = create_sphere_objects(
            points, 
            colors, 
            RENDER_SETTINGS['point_size']
        )
        
        # Set camera position and rotation
        location, rotation = get_camera_transform(frame_number, total_frames)
        camera.location = location
        camera.rotation_euler = rotation
        
        # Insert keyframes for camera
        camera.keyframe_insert(data_path="location", frame=frame_number)
        camera.keyframe_insert(data_path="rotation_euler", frame=frame_number)
        
        # Set interpolation to linear for smooth motion
        if camera.animation_data and camera.animation_data.action:
            for fcurve in camera.animation_data.action.fcurves:
                for keyframe in fcurve.keyframe_points:
                    keyframe.interpolation = 'LINEAR'
        
        # Render frame
        bpy.context.scene.render.filepath = str(output_path / f"frame_{{frame_number:04d}}")
        bpy.ops.render.render(write_still=True)
    
    print("Rendering completed!")

if __name__ == "__main__":
    main()
'''
        return script